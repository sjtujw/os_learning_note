# os_learning_note
learning note of operating system from PeKing University
## memory model 1
### memory management（存储管理）
#### 基本概念
* 地址重定位（relocation）
    - 概念<br>
    为了保证CPU执行指令时可正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址，这一过程称为地址重定位
    - 逻辑地址（相对地址、虚拟地址）<br>
    用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址<br>
    不能用逻辑地址在内存中读取信息。<br>
    - 物理地址（绝对地址、实地址）<br>
    内存中存储单元的地址，可直接寻址
    - 静态重定位<br>
    当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换，软件
    - 动态重定位<br>
    在进程执行过程中进行地址变换 ————>>> 即逐条指令执行时完成地址转换，硬件
    - 实现<br>
    ![dynamic_relocation](https://github.com/sjtujw/os_learning_note/raw/master/img/dynamic_relocation.jpg)
#### 物理内存管理
* 空闲内存管理
    - 数据结构：<br>
    位图法、空闲区表、空闲区链表
* 内存分配算法
    - 首次适配 first fit：在空闲区表中找到第一个满足进程要求的空闲区
    - 下次适配 next fit：从上次找到的空闲区处接着查找
    - 最佳适配 best fit：查找整个空闲区表，找到能够满足进程要求的最小空闲区
    - 最差适配 worst fit：总是分配满足进程要求的最大空闲区
* 回收问题（算法）
    - 当某一块归还后，前后空闲空间合并，修改内存空闲区表
    - 四种情况：上相邻、下相邻、上下都相邻、上下都不相邻
#### 伙伴系统
* 算法：
    - 首先将整个可用空间看作一块： 2^U
    - 假设进程申请的空间大小为 s，如果满足<br>
            2^(U-1) < s <= 2^U，则分配整个块<br>
    否则，将块划分为两个大小相等的伙伴，大小为2^(U-1)<br>
    - 一直划分下去直到产生大于或等于 s 的最小块
#### 基本内存管理方案
![manage_method](https://github.com/sjtujw/os_learning_note/raw/master/img/manage_method.jpg)
* 单一连续区<br>
    特点：一段时间内只有一个进程在内存简单，内存利用率低
* 固定分区<br>
    内存空间固定分为若干区域，大小可相同可不同，固定不变，每个分区装一个进程
* 可变分区<br>
    根据进程需要，分割出一部分内存空闲区域分区，给该进程，剩余新的空闲区
    - 碎片问题：<br>
    紧缩技术（压缩技术、紧致技术、搬家技术）：在内存移动程序，将所有小的空闲区合并成大的空闲区
* 页式
    - 用户进程地址空间被划分为大小相等的部分，称为页（page）或页面，从0开始编号；内存空间同样划分，称为页框，也叫物理页面，页帧，内存块；
    - 内存分配规则：以页为单位进行分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻，常见4K、4M。
    - 相关数据结构及地址转换<br>
        + 页表项：记录了逻辑页号与页框号的对应关系<br>
        + 每个进程一个页表，存放在内存<br>
        + 地址转换<br>
        CPU取到逻辑地址，自动划分为页号和页内地址；用页号查页表，得到页框号，再与页内偏移拼接成为物理地址
* 段式
* 段页式
#### 交换技术（swapping）